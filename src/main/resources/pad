-------------------------------------------------------------------------------
-- deterministic analysis

is-rules-determ .group :- group-rules .group .goal, is-determ .goal #

group-rules () fail #
group-rules (.head :- .tail # .remains) (IN = .head, .tail; .remains1)
	:- group-rules .remains .remains1
#

is-determ (.a, .b) :- is-determ .a, is-determ .b #
is-determ .goal :- is-cut-determ .goal #
is-determ (.a; .b) :- is-cut-determ .a, is-determ .b #
is-determ (.a = .b) #
is-determ yes #
is-determ fail #

is-cut-determ .goal :- split-cut .goal .afterCut, !, is-determ .afterCut #

split-cut .cut () :- to.atom "!" .cut #
split-cut (.cut, .c) .c :- to.atom "!" .cut #
split-cut (_, .c0) .c1 :- split-cut .c0 .c1 #

-------------------------------------------------------------------------------
-- longest common subsequence

lcs .a .b .lcs :- lcs-memoized .a .b .lcs ()/_ #

lcs-memoized .a .b .lcs .t0/.tx
	:- hash .a/.b .hash
	, t23-map .hash/.cached .t0/.t1
	, once (bound .cached, .t1 = .tx; lcs0 .a .b .cached .t1/.tx)
	, .lcs = .cached
#

lcs0 () _ () _ :- ! #
lcs0 _ () () _ :- ! #
lcs0 (.head, .tail1) (.head, .tail2) (.head, .lcs) .t0/.tx
	:- lcs-memoized .tail1 .tail2 .lcs .t0/.tx
	, !
#
lcs0 (.head1, .tail1) (.head2, .tail2) .lcs .t0/.tx
	:- lcs-memoized (.head1, .tail1) .tail2 .lcs1 .t0/.t1
	, lcs-memoized .tail1 (.head2, .tail2) .lcs2 .t1/.tx
	, longer .lcs1 .lcs2 .lcs
#

longer .l .r .result :- longer0 .l .r L, !, .result = .l; .result = .r #

longer0 _ () L #
longer0 () _ R #
longer0 (_, .l1) (_, .l2) .which :- longer0 .l1 .l2 .which #

-------------------------------------------------------------------------------
-- format check

define-signature .sign :- signature-prototype .sign .sign #

check-module-types (.rule # .remains) :- check-clause-types .rule, check-module-types .remains #
check-module-types () #

check-clause-types (.head :- .clause) :- check-rule-types .head .clause #
check-clause-types .head :- not (head = ()), check-rule-types .head () #
check-clause-types () #

check-clause-types (.c1, .c2) :- check-clause-types .c1, check-clause-types .c2 #
check-clause-types (.c1; .c2) :- check-clause-types .c1, check-clause-types .c2 #
check-clause-types (.c1 = .c2) :- is-type .type .c1, is-type .type .c2 #

check-rule-types .head .clause
	:- prototype .head .proto
	, retrieve-signature .head .types
	, is-type .types .head
	, check-clause-types .clause
#

is-type %any _ #
is-type %integer .i :- is.int .i #
is-type %string .s :- is.string .s #
is-type (.type | _) .e :- is-type .type .e #
is-type (_ | .remains) .e :- is-type .remains .e #
is-type (%list .type) (.head, .remains)
	:- is-type .type .head
	, is-type (%list .type) .remains
#
is-type .alias .e :- map.retrieve (TYPE-ALIAS .alias, .value), bound .value, is-type .value .e #
is-type .treeType .tree
	:- tree .tree .left .operator .right
	, tree .treeType .leftType .operator .rightType
	, is-type .leftType .left, is-type .rightType .right
#
is-type .a .a :- is.atom .a, not (starts.with .a '%') #

signature-prototype .sign .proto :- prototype .sign .proto, map.retrieve (SIGNATURE .sign, .proto) #

prototype (.head .remains0) (.head .remains1) :- params-prototype .remains0 .remains1, ! #

params-prototype (_, .remains0) ((), .remains1) :- params-prototype .remains0 .remains1, ! #
params-prototype () () #
