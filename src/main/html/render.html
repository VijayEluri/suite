<meta charset='utf-8'>
<html>
	<body>
		<div id='target'></div>
	</body>

	<script src='frp.js'></script>
	<script src='fun.js'></script>

	<script type='text/javascript'>
'use strict';

let newElement = (tag, attrs = [], children = []) => {
	let el = document.createElement(tag);
	for (let [key, value] of Object.entries(attrs))
		el.setAttribute(key, value);
	for (let child of children)
		el.appendChild(child);
	return el;
};

/*
	a typical renderer has 4 parameters:
	vm0 - old view model, null to append DOM elements
	vm1 - new view model, null to remove DOM elements
	dom - current DOM parent node
	domc - current DOM node
	The renderer should detect the differences and apply changes under dom, or directly update domc.
*/

let rd_cd = (cf, df) => (vm0, vm1, dom, domc) => {
	if (vm0 == vm1)
		;
	else {
		vm0 != null && df(vm0, dom, domc);
		vm1 != null && cf(vm1, dom, domc);
	}
};

let rd_child = elementf => rd_cd(
	(vm, dom, domc) => dom.appendChild(domc = elementf(vm)),
	(vm, dom, domc) => dom.removeChild(domc)
);

let rd_element = (elementf, decorfs) => (vm0, vm1, dom, domc) => {
	if (vm0 == null)
		dom.appendChild(domc = elementf());
	if (vm0 != vm1)
		for (let decorf of decorfs)
			decorf(vm0, vm1, dom, domc);
	if (vm1 == null)
		dom.removeChild(domc);
};

let rd_for = (keyf, rdf) => (vm0, vm1, dom, domc) => {
	if (vm0 == vm1)
		;
	else if (vm0 == null)
		for (let i1 = 0; i1 < vm1.length; i1++)
			rdf(null, vm1[i1], domc, null);
	else if (vm1 == null) {
		let children = Array.from(domc.childNodes);
		for (let i0 = 0; i0 < vm0.length; i0++)
			rdf(vm0[i0], null, domc, children[i0]);
	} else {
		let children = Array.from(domc.childNodes);
		let map0 = new Map();
		let map1 = new Map();

		for (let i0 = 0; i0 < vm0.length; i0++)
			map0.set(keyf(vm0[i0]), i0);
		for (let i1 = 0; i1 < vm1.length; i1++)
			map1.set(keyf(vm1[i1]), i1);

		let isSameOrder = vm0.length == vm1.length;
		let domc0 = domc;

		for (let i1 = 0; i1 < vm1.length; i1++) {
			let i0 = map0.get(keyf(vm1[i1]));
			isSameOrder &= i0 == i1;
		}

		if (isSameOrder)
			for (let i = 0; i < vm1.length; i++)
				rdf(vm0[i], vm1[i], domc, children[i]);
		else {
			dom.replaceChild(domc = domc0.cloneNode(false), domc0);

			for (let i1 = 0; i1 < vm1.length; i1++) {
				let i0 = map0.get(keyf(vm1[i1]));
				if (i0 != null) {
					let child0 = children[i0];
					domc.appendChild(child0);
					rdf(vm0[i0], vm1[i1], domc, child0);
				} else
					rdf(null, vm1[i1], domc, null);
			}

			for (let i0 = 0; i0 < vm0.length; i0++)
				if (!map1.has(keyf(vm0[i0])))
					rdf(vm0[i0], null, domc0, domc0.childNodes[i0]);
		}
	}
};

let rd_ifElse = (iff, thenf, elsef) => (vm0, vm1, dom, domc) => {
	if (vm0 == vm1)
		;
	else {
		let f0 = vm0 != null && (iff(vm0) ? thenf : elsef);
		let f1 = vm1 != null && (iff(vm1) ? thenf : elsef);

		if (f0 == f1)
			f0(vm0, vm1, dom, domc);
		else {
			f0 != null && f0(vm0, null, dom, domc);
			f1 != null && f1(null, vm1, dom, domc);
		}
	}
};

let rd_tagAttrfs = attrs => (vm0, vm1, dom, domc) => {
	if (vm0 == vm1)
		;
	else if (vm1 != null)
		for (let [key, valuef] of Object.entries(attrs))
			domc.setAttribute(key, valuef(vm1));
};

let rd_tagAttrs = attrs => rd_cd(
	(vm, dom, domc) => {
		for (let [key, value] of Object.entries(attrs))
			domc.setAttribute(key, value);
	}, 
	(vm, dom, domc) => {
		for (let [key, value] of Object.entries(attrs))
			domc.removeAttribute(key);
	},
);

let rd_tagChildren = childrenfs => (vm0, vm1, dom, domc) => {
	if (vm0 == vm1)
		;
	else if (vm0 == null)
		for (let i = 0; i < childrenfs.length; i++)
			childrenfs[i](vm0, vm1, domc, null);
	else if (vm1 == null) {
		let children = Array.from(domc.childNodes);
		for (let i = 0; i < childrenfs.length; i++)
			childrenfs[i](vm0, vm1, domc, children[i]);
	} else
		for (let i = 0; i < childrenfs.length; i++)
			childrenfs[i](vm0, vm1, domc, domc.childNodes[i]);
};

let rd_tagEventListener = (event, cb) => rd_cd(
	(vm, dom, domc) => domc.addEventListener(event, cb),
	(vm, dom, domc) => domc.removeEventListener(event, cb)
);

let rd = {
	child: rd_child,
	for: rd_for,
	if_: (iff, thenf) => rd_ifElse(iff, thenf, rd_child(() => document.createComment('else'))),
	ifElse: rd_ifElse,
	scope: (key, rdf) => (vm0, vm1, dom, domc) => rdf(
		vm0 != null ? vm0[key] : null,
		vm1 != null ? vm1[key] : null,
		dom, domc
	),
	tag: (tag, ...decorfs) => rd_element(() => newElement(tag), decorfs),
	tagAttr: (key, value) => rd_tagAttrs({ [key]: value, }),
	tagAttrfs: rd_tagAttrfs,
	tagAttrs: rd_tagAttrs,
	tagChildren: (...childrenfs) => rd_tagChildren(childrenfs),
	tagChildrenList: rd_tagChildren,
	tagListen: rd_tagEventListener,
};

let pvm = null;

let renderAgain = (renderer, vm) => {
	let target = document.getElementById('target');
	renderer(pvm, vm, target, target.firstChild);
	pvm = vm;
};

let text = rd.child(vm => document.createTextNode(vm));

let rd_vm = rd.tag('span',
	rd.tagChildren(
		rd.scope('message',
			rd.tag('p', rd.tagAttr('style', 'font-weight: bold;'), rd.tagChildren(text,))
		),
		rd.scope('fruits',
			rd.tag('ul', rd.for(vm => vm, rd.tag('li', rd.tagChildren(text,))))
		),
		rd.tag('div',
			rd.tagAttr('style', 'height: 200px; overflow: auto; position: absolute;'),
			rd.tagListen('scroll', d => {
				console.log('scrollTop', d.target.scrollTop);
			}),
			rd.tagChildren(rd.tag('div',
				rd.tagAttrfs({
					style: () => 'top: 20px; position: relative;',
				}),
				rd.tagChildrenList(read()
					.range(0, 256)
					.map(i => rd.tag('div', rd.tagChildren(rd.child(vm => document.createTextNode('scrolling ' + i)),)))
					.list()
				),
			),),
		),
	)
);

renderAgain(rd_vm, { message: 'hello world0', fruits: ['banana',], });
renderAgain(rd_vm, { message: 'hello world1', fruits: ['apple', 'banana',], });
renderAgain(rd_vm, { message: 'hello world2', fruits: ['apple', 'orange', 'orange', 'banana',], });
renderAgain(rd_vm, { message: 'hello world~', fruits: ['banana', 'orange',], });
	</script>

</html>
