using external STANDARD >>
using external CHARS >>
-------------------------------------------------------------------------------
define lower := ch =>
  if (65 <= ch && ch <= 90) then (ch + 32) else ch
>>
define upper := ch =>
  if (97 <= ch && ch <= 122) then (ch - 32) else ch
>>
-------------------------------------------------------------------------------
define camel-case := s =>
  if (s != "") then (upper {head {s}}; map {lower} {tail {s}}) else s
>>
define int-to-str := i =>
	let unsigned-int-to-str :=
		reverse
		. map {`+ +'0'`}
		. unfold-right {i => optional {i != 0} {i % 10, i / 10}}
	>> i |
		if (i > 0) then
			unsigned-int-to-str
		else-if (i < 0) then
			append {"-"} . unsigned-int-to-str . `0 -`
		else
			anything => "0"
>>
define str-to-int := s =>
	let unsigned-str-to-int := fold-left {v => d => v * 10 + d - 48} {0} >>
		if (is-list {s} && head {s} = +'-')
		then (`0 -` . unsigned-str-to-int . tail)
		else unsigned-str-to-int
	{s}
>>
-------------------------------------------------------------------------------
define dump := (:t => :t -> string) of skip-type-check (
	define type-of := getintrn {atom:INTRN!BasicIntrinsics.typeOf} >>
	define atom-string := getintrn {atom:INTRN!BasicIntrinsics.atomString} >>
	let dump0 := prec => n =>
		let type := +callintrn-v1 {type-of} {n} >>
		if (n = ()) then
			"()"
		else-if (type = TREE) then
			concat {dump0 {true} {n | head}; "; "; dump0 {false} {n | tail};}
			| if prec then (s => concat {"("; s; ")";}) else id
		else-if (type = ATOM) then
			callintrn-v1 {atom-string} {n}
		else
			int-to-str {n}
	>>
	dump0 {false}
) >>
define sh := command => in =>
	do >>
	in | popen {"sh"; "-c"; command;} | perform | second | first | map {cs-to-string} | concat
>>
