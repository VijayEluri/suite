-- type check

-- parser

-- compiler

compile () () (.c .c) #
compile () .more (.c0 .cx)
	:- compile .more () (.c0 .cx)
#
compile () (JMP .label) (.c0 .cx)
	:- .c0 = (JMP .label, .cx)
#
compile (.a, .b) .more (.c0 .cx)
	:- compile .a (.b, .more) (.c0 .cx)
#
compile (.a; .b) .more (.c0 .cx)
	:- .c0 = (PUSH-BACKTRACK-POINT, .c1)
	, compile .a (JMP .label) .c1 .c2
	, .c2 = (LABEL .label, .c3)
	, compile .a () .c3 .cx
#
compile (.a = .b) .more (.c0 .cx)
	:- createNode .a .reg0 (.c0 .c1)
	, createNode .a .reg1 (.c1 .c2)
	, .c2 = (JUMP-FAIL .reg0 .reg1, .cx)
#

createNode .a .reg (.c0 .cx)
	:- is.atom .a, .c0 = (ASSIGN-ATOM .reg .a, .cx)
#
createNode .i .reg (.c0 .cx)
	:- is.int .i, .c0 = (ASSIGN-INT .reg .i, .cx)
#
createNode .s .reg (.c0 .cx)
	:- is.string .s, .c0 = (ASSIGN-STRING .reg .s, .cx)
#
createNode .tree .reg (.c0 .cx)
	:- tree (.tree, .left, .operator, .right)
	, createNode .left .regl (.c0 .c1)
	, createNode .right .regr (.c1 .c2)
	, .c2 = (FORM-TREE .operator .regl .regr, .cx)
#

isUserPredicate .call :- was.success (isUserPredicate0 .call) #

isUserPredicate0 .call :- rules .rules, hasRules .rules (.call :- _) #

hasRules (.rule # _) .rule #
hasRules (_ # .remains) .rule :- hasRules .remains .rule #
