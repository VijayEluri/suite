<meta charset='utf-8'>
<html>
	<body>
		<div id='target'></div>
	</body>

	<script src='frp.js'></script>
	<script src='fun.js'></script>

	<script type='text/javascript'>
'use strict';

let newElement = (tag, attrs, children) => {
	let el = document.createElement(tag);
	if (attrs != null)
		for (let [key, value] of Object.entries(attrs))
			el.setAttribute(key, value);
	if (children != null)
		for (let child of children)
			el.appendChild(child);
	return el;
};

/*
	a typical renderer has 4 parameters:
	vm0 - old view model, null to append DOM elements
	vm1 - new view model, null to remove DOM elements
	dom - current DOM parent node
	domc - current DOM node
	The renderer should detect the differences and apply changes under dom, or directly update domc.
*/

let rd_element = (elementf, childrenf) => (vm0, vm1, dom, domc) => {
	if (vm0 == null) {
		dom.appendChild(domc = elementf());
		for (let childf of childrenf)
			childf(null, vm1, domc, null);
	} else if (vm1 == null)
		dom.removeChild(domc);
	else if (vm0 != vm1)
		for (let i = 0; i < childrenf.length; i++)
			childrenf[i](vm0, vm1, domc, domc.childNodes[i]);
	return domc;
};

let rd_for = (elementf, keyf, rdf) => (vm0, vm1, dom, domc) => {
	if (vm0 == null) {
		dom.appendChild(domc = elementf());
		for (let i = 0; i < vm1.length; i++) rdf(null, vm1[i], domc, null);
	} else if (vm1 == null)
		dom.removeChild(domc);
	else if (vm0 != vm1) {
		let map0 = new Map();
		for (let i0 = 0; i0 < vm0.length; i0++) map0.set(keyf(vm0[i0]), i0);

		let isSameOrder = true;
		let domc0 = domc;
		let dom_i1 = [];
		let indices0 = [];

		for (let i1 = 0; i1 < vm1.length; i1++) {
			var i0 = map0.get(keyf(vm1[i1]));
			isSameOrder &= i0 == i1;
			dom_i1.push(domc.childNodes[i0]);
			indices0.push(i0);
		}

		if (isSameOrder)
			for (let i = 0; i < vm1.length; i++)
				rdf(vm0[i], vm1[i], domc, dom_i1[i]);
		else {
			domc = domc0.cloneNode(false);
			for (let i1 = 0; i1 < vm1.length; i1++) {
				let i0 = indices0[i1];
				if (i0 != null) {
					let child0 = dom_i1[i1];
					domc.appendChild(child0);
					rdf(vm0[i0], vm1[i1], domc, child0);
				} else
					rdf(null, vm1[i1], domc, null);
			}
			dom.replaceChild(domc, domc0);
		}
	}
	return domc;
};

let rd = {
	attr: (rdf, name, attrf) => (vm0, vm1, dom, domc) => {
		if (vm0 != vm1) {
			domc = rdf(vm0, vm1, dom, domc);
			if (vm1 == null) domc.removeAttribute(name);
			domc.setAttribute(name, attrf(vm1));
		}
		return domc;
	},
	c: elementf => (vm0, vm1, dom, domc) => {
		if (vm0 != vm1) {
			if (vm0 != null) dom.removeChild(domc);
			if (vm1 != null) dom.appendChild(elementf(vm1), domc);
		}
		return domc;
	},
	scope: (key, rdf) => (vm0, vm1, dom, domc) => rdf(
		vm0 != null ? vm0[key] : null,
		vm1 != null ? vm1[key] : null,
		dom, domc),
	tag: (tag, childrenf) => rd_element(() => newElement(tag), childrenf),
	tag_for: (tag, keyf, rdf) => rd_for(() => newElement(tag), keyf, rdf),
};

let pvm = null;

let renderAgain = (renderer, vm) => {
	let target = document.getElementById('target');
	renderer(pvm, vm, target, target.firstChild);
	pvm = vm;
};

let textf = rd.c(vm => document.createTextNode(vm));

let rd_vm = rd.tag('span', [
	rd.scope('message', rd.tag('p', [textf])),
	rd.scope('fruits',
		rd.tag_for('ul', vm => vm, rd.tag('li', [textf]))),
]);

renderAgain(rd_vm, { message: 'hello world0', fruits: ['banana',], });
renderAgain(rd_vm, { message: 'hello world1', fruits: ['apple', 'banana',], });
renderAgain(rd_vm, { message: 'hello world2', fruits: ['apple', 'orange', 'banana',], });
renderAgain(rd_vm, { message: 'hello world~', fruits: ['banana', 'orange',], });
	</script>

</html>
