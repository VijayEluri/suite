-------------------------------------------------------------------------------
-- deterministic analysis

group-predicates (.head :- .tail # .remains) (IN = .head, .tail; .groupedRemains)
	:- group-predicates .remains .groupedRemains
#
group-predicates () fail #

replace-cut-points .predicates0 (DEFINE-CUT .cutPoint .predicates1)
       :- replace .predicates0 .predicates1 ! .cutPoint
#

is-determ (!, _) #
is-determ (.a, .b) :- is-determ .a, is-determ .b #
is-determ (fail; .c) :- is-determ .c #
is-determ (.c; fail) :- is-determ .c #
is-determ (.ifThen; .else)
	:- split-cut .ifThen .then
	, is-determ .then
	, is-determ .else
#
is-determ (.a = .b) #
is-determ yes #
is-determ fail #

split-cut ! () #
split-cut (!, .c) .c #
split-cut (_, .c0) .c1 :- split-cut .c0 .c1 #

-------------------------------------------------------------------------------
-- format check

define-signature .sign :- signature-prototype .sign .sign #

check-module-types (.rule # .remains) :- check-clause-types .rule, check-module-types .remains #
check-module-types () #

check-clause-types (.head :- .clause) :- check-rule-types .head .clause #
check-clause-types .head :- not (head = ()), check-rule-types .head () #
check-clause-types () #

check-clause-types (.c1, .c2) :- check-clause-types .c1, check-clause-types .c2 #
check-clause-types (.c1; .c2) :- check-clause-types .c1, check-clause-types .c2 #
check-clause-types (.c1 = .c2) :- is-type .type .c1, is-type .type .c2 #

check-rule-types .head .clause
	:- prototype .head .proto
	, retrieve-signature .head .types
	, is-type .types .head
	, check-clause-types .clause
#

is-type %any _ #
is-type %integer .i :- is.int .i #
is-type %string .s :- is.string .s #
is-type (.type | _) .e :- is-type .type .e #
is-type (_ | .remains) .e :- is-type .remains .e #
is-type (%list .type) (.head, .remains)
	:- is-type .type .head
	, is-type (%list .type) .remains
#
is-type .alias .e :- map.retrieve (TYPE-ALIAS .alias, .value), bound .value, is-type .value .e #
is-type .treeType .tree
	:- tree .tree .left .operator .right
	, tree .treeType .leftType .operator .rightType
	, is-type .leftType .left, is-type .rightType .right
#
is-type .a .a :- is.atom .a, not (starts.with .a '%') #

signature-prototype .sign .proto :- prototype .sign .proto, map.retrieve (SIGNATURE .sign, .proto) #

prototype (.head .remains0) (.head .remains1) :- params-prototype .remains0 .remains1, ! #

params-prototype (_, .remains0) ((), .remains1) :- params-prototype .remains0 .remains1, ! #
params-prototype () () #

-------------------------------------------------------------------------------
-- pattern recog

-------------------------------------------------------------------------------
-- lexer

-------------------------------------------------------------------------------
-- longest common subsequence

lcs () _ () :- ! #
lcs _ () () :- ! #
lcs (.common, .remains1) (.common, .remains2) (.common, .lcs)
	:- lcs-once .remains1 .remains2 .lcs, !
#
lcs (.head1, .remains1) (.head2, .remains2) .lcs
	:- lcs-once (.head1, .remains1) .remains2 .lcs1
	, lcs-once .remains1 (.head2, .remains2) .lcs2
	, longest .lcs1 .lcs2 .lcs
#

-- Note memory leak
lcs-once .a .b .lcs :- map.retrieve (LCS .a .b) .lcs, (bound .lcs, !; lcs .a .b .lcs) #

longest .l .r .result
	:- longest0 .l .r L, !, .result = .l; .result = .r
#

longest0 .l () L #
longest0 () .l R #
longest0 (_, .l1) (_, .l2) .which :- longest0 .l1 .l2 .which #
