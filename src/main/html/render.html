<meta charset='utf-8'>
<html>
	<body>
		<div id='target'></div>
	</body>

	<script src='frp.js'></script>
	<script src='fun.js'></script>

	<script type='text/javascript'>
'use strict';

let newElement = (tag, attrs, children) => {
	let el = document.createElement(tag);
	if (attrs != null)
		for (let [key, value] of Object.entries(attrs))
			el.setAttribute(key, value);
	if (children != null)
		for (let child of children)
			el.appendChild(child);
	return el;
};

/*
	a typical renderer has 4 parameters:
	vm0 - old view model, null to append DOM elements
	vm1 - new view model, null to remove DOM elements
	dom - current DOM parent node
	domc - current DOM node
	The renderer should detect the differences and apply changes under dom, or directly update domc.
*/

let rd_element = (elementf, decorfs) => (vm0, vm1, dom, domc) => {
	if (vm0 != vm1) {
		if (vm0 == null) dom.appendChild(domc = elementf());
		for (let decorf of decorfs) decorf(vm0, vm1, dom, domc);
		if (vm1 == null) dom.removeChild(domc);
	}
};

let rd_for = (keyf, rdf) => (vm0, vm1, dom, domc) => {
	if (vm0 == null) {
		for (let i1 = 0; i1 < vm1.length; i1++) rdf(null, vm1[i1], domc, null);
	} else if (vm1 == null) {
		let children = Array.from(domc.childNodes);
		for (let i0 = 0; i0 < vm0.length; i0++) rdf(vm0[i0], null, domc, children[i0]);
	} else if (vm0 != vm1) {
		let children = Array.from(domc.childNodes);
		let map0 = new Map();
		let map1 = new Map();
		for (let i0 = 0; i0 < vm0.length; i0++) map0.set(keyf(vm0[i0]), i0);
		for (let i1 = 0; i1 < vm1.length; i1++) map1.set(keyf(vm1[i1]), i1);

		let isSameOrder = vm0.length == vm1.length;
		let domc0 = domc;

		for (let i1 = 0; i1 < vm1.length; i1++) {
			let i0 = map0.get(keyf(vm1[i1]));
			isSameOrder &= i0 == i1;
		}

		if (isSameOrder)
			for (let i = 0; i < vm1.length; i++)
				rdf(vm0[i], vm1[i], domc, children[i]);
		else {
			domc = domc0.cloneNode(false);

			for (let i1 = 0; i1 < vm1.length; i1++) {
				let i0 = map0.get(keyf(vm1[i1]));
				if (i0 != null) {
					let child0 = children[i0];
					domc.appendChild(child0);
					rdf(vm0[i0], vm1[i1], domc, child0);
				} else
					rdf(null, vm1[i1], domc, null);
			}

			dom.replaceChild(domc, domc0);

			for (let i0 = 0; i0 < vm0.length; i0++)
				if (!map1.has(keyf(vm0[i0])))
					rdf(vm0[i0], null, domc0, domc0.childNodes[i0]);
		}
	}
};

let rd_ifElse = (iff, thenf, elsef) => (vm0, vm1, dom, domc) => {
	if (vm0 == null)
		(iff(vm1) ? thenf : elsef)(vm0, vm1, dom, null);
	else if (vm1 == null)
		(iff(vm0) ? thenf : elsef)(vm0, vm1, dom, domc);
	else if (vm0 != vm1)
		if (iff(vm0) == iff(vm1))
			thenf(vm0, vm1, dom, domc);
		else
			(iff(vm1) ? thenf : elsef)(vm0, vm1, dom, domc);
};

let rd_if = (iff, thenf) => rd_ifElse(iff, thenf, (vm0, vm1, dom, domc) => {
	if (vm0 == null)
		dom.appendChild(document.createComment('else'));
	else if (vm1 == null)
		dom.removeChild(domc);
	else if (vm0 != vm1)
		dom.replaceChild(document.createComment('else'), domc);
});

let rd = {
	attr: (key, value) => (vm0, vm1, dom, domc) => {
		if (vm0 != vm1) {
			if (vm0 != null) domc.removeAttribute(key);
			if (vm1 != null) domc.setAttribute(key, value);
		}
	},
	c: elementf => (vm0, vm1, dom, domc) => {
		if (vm0 != vm1) {
			if (vm0 != null) dom.removeChild(domc);
			if (vm1 != null) dom.appendChild(elementf(vm1));
		}
	},
	children: (...childrenfs) => (vm0, vm1, dom, domc) => {
		if (vm0 == null)
			for (let i = 0; i < childrenfs.length; i++)
				childrenfs[i](vm0, vm1, domc, null);
		else if (vm1 == null) {
			let children = Array.from(domc.childNodes);
			for (let i = 0; i < childrenfs.length; i++)
				childrenfs[i](vm0, vm1, domc, children[i]);
		} else if (vm0 != vm1)
			for (let i = 0; i < childrenfs.length; i++)
				childrenfs[i](vm0, vm1, domc, domc.childNodes[i]);
	},
	for: rd_for,
	ifElse: rd_ifElse,
	scope: (key, rdf) => (vm0, vm1, dom, domc) => rdf(
		vm0 != null ? vm0[key] : null,
		vm1 != null ? vm1[key] : null,
		dom, domc
	),
	tag: (tag, ...decorfs) => rd_element(() => newElement(tag), decorfs),
};

let pvm = null;

let renderAgain = (renderer, vm) => {
	let target = document.getElementById('target');
	renderer(pvm, vm, target, target.firstChild);
	pvm = vm;
};

let text = rd.c(vm => document.createTextNode(vm));

let rd_vm = rd.tag('span',
	rd.children(
		rd.scope('message',
			rd.tag('p', rd.attr('style', 'font-weight: bold;'), rd.children(text))
		),
		rd.scope('fruits',
			rd.tag('ul', rd.for(vm => vm, rd.tag('li', rd.children(text))))
		)
	)
);

renderAgain(rd_vm, { message: 'hello world0', fruits: ['banana',], });
renderAgain(rd_vm, { message: 'hello world1', fruits: ['apple', 'banana',], });
renderAgain(rd_vm, { message: 'hello world2', fruits: ['apple', 'orange', 'orange', 'banana',], });
renderAgain(rd_vm, { message: 'hello world~', fruits: ['banana', 'orange',], });
	</script>

</html>
