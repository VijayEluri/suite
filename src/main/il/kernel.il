-- TODO garbage collection

-- Physical memory layout
-- 00000000 -> 00100000 refer logical memory layout below
-- 00100000 -> stackx   physical page stack
-- stackx   -> pagex    allocatable physical pages

-- Logical memory layout
-- 00007C00 -> 00007E00 boot sector
-- 00020000 -> 00020800 interrupt descriptor table (IDT)
-- 00020800 -> 00020868 task state segment (TSS)
-- 00020870 -> 00023000 kernel first stack
-- 00023000 -> 00024000 kernel second stack
-- 00040000 -> 00040004 kernel this frame pointer
-- 00040000 -> 00050000 kernel code
-- 00050000 -> 000A0000 kernel buddy allocation pool
-- 000A0000 -> 00100000 BIOS / video memory
-- 00800000 -> FFC00000 allocatable logical pages
-- FFC00000 -> FFFFF000 second level page tables, for the current address space
-- FFFFF000 -> end      first level page table, for the current address space

constant idt-address = +x20000;
constant tss-address = +x20800;
constant kernel-first-esp = +x23000;
constant kernel-second-esp = +x24000;
constant memory-region-start = 1048576;

asm _ MOV (ESP, kernel-first-esp);
asm _ MOV (EBP, ESP);
asm _ MOV (`+x40000`, EBP);

declare ticks = 0;

declare copy = function [dst, src, len,] (
	asm _ CLD ();
	asm _ MOV (EDI, `EBP + 12`);
	asm _ MOV (ESI, `EBP + 16`);
	asm _ MOV (ECX, `EBP + 20`);
	asm _ SHR (ECX, 2);
	asm _ REP MOVSD ();
	asm _ MOV (ECX, `EBP + 20`);
	asm _ AND (ECX, 3);
	asm _ REP MOVSB ();
);

declare zero = function [dst, len,] (
	asm _ XOR (EAX, EAX);
	asm _ CLD ();
	asm _ MOV (EDI, `EBP + 12`);
	asm _ MOV (ECX, `EBP + 16`);
	asm _ SHR (ECX, 2);
	asm _ REP STOSD ();
	asm _ MOV (ECX, `EBP + 16`);
	asm _ AND (ECX, 3);
	asm _ REP STOSB ();
);

declare dw-get = function [p,] (
	`p as pointer:int`;
);

declare dw-set = function [p, i,] (
	let `p as pointer:int` = i;
);

declare inb = function [port,] (
	asm _ MOV (EDX, `EBP + 12`);
	asm _ XOR (EAX, EAX);
	asm _ IN (AL, DX);
);

declare inw = function [port,] (
	asm _ MOV (EDX, `EBP + 12`);
	asm _ XOR (EAX, EAX);
	asm _ IN (AX, DX);
);

declare outb = function [port, value,] (
	asm _ MOV (EDX, `EBP + 12`);
	asm _ MOV (EAX, `EBP + 16`);
	asm _ OUT (DX, AL);
);

declare outw = function [port, value,] (
	asm _ MOV (EDX, `EBP + 12`);
	asm _ MOV (EAX, `EBP + 16`);
	asm _ OUT (DX, AX);
);

declare wrmsr = function [msr, value,] (
	asm _ MOV (ECX, `EBP + 12`);
	asm _ MOV (EAX, `EBP + 16`);
	asm _ XOR (EDX, EDX);
	asm _ WRMSR ();
);

#include(bitmap.il);
#include(doubly-ll.il);
#include(sync.il);
#include(console.il);
#include(buddy-allocator.il);
#include(first-fit-allocator.il);

constant mm-allocate .type = (
	(ba-allocate [size-of .type,]) as pointer:.type
);
constant mm-deallocate .type .pointer = (
	ba-deallocate [address `.pointer`, size-of .type,]
);

#include(irq.il);
#include(scheduler.il);
#include(idt.il);
#include(phy-mem.il);
#include(paging.il);
#include(service.il);
#include(time.il);
#include(keyboard.il);
#include(harddisk.il);
#include(ne2k.il);

-- Reprograms the PIC to relocate IRQs to interrupt 20h-2Fh
(
	declare d0 = inb [+x21,];
	declare d1 = inb [+xA1,];
	outb [+x20, +x11,]; -- Initializes and disables ICW4
	outb [+xA0, +x11,];
	outb [+x21, +x20,]; -- Remaps IRQ0-7
	outb [+xA1, +x28,]; -- Remaps IRQ8-F
	outb [+x21, +x04,];
	outb [+xA1, +x02,];
	outb [+x21, +x01,]; -- 8086/88 (MCS-80/85) mode
	outb [+xA1, +x01,];
	outb [+x21, d0,];
	outb [+xA1, d1,];
);

-- Sets the 8253 to 100 timer ticks per second, and enables keyboard
outb [+x43, +x36,];
outb [+x40, 11932 % 256,];
outb [+x40, 11932 / 256,];
outb [+x21, +xFC,];

-- Initializes task state segment (TSS)
for (declare i = 0; i < 104; i =+ 4) (
	dw-set [tss-address + i, 0,];
);
--dw-set [tss-address + 4, current-process as int + size-of sch-node,]; -- Set by scheduler instead
dw-set [tss-address + 8, +x10,];

asm _ MOV (AX, +x2B);
asm _ LTR (AX);

declare user-mode = function [] (
	asm .user PUSH (`+x40000`);
	asm _ MOV (EBP, ESP);

	-- Shows OK
	svc-service [svc-putc_, +x4F, 0,];
	svc-service [svc-putc_, +x4B, 0,];
	svc-service [svc-putc_, +x0A, 0,];

	while 1 do (time-yield []);
);

-- Switch stack to keep stack smaller so as to fit in the process stack space.
-- Global scope variables, defined before this point, are kept in the first stack.
asm _ MOV (ESP, kernel-second-esp);

(function [] (
	asm _ MOV (EAX, `+x40000`);
	asm _ MOV (`EBP`, EAX);

	ba-setup [];
	irq-setup [];
	sch-setup [];
	idt-setup [];
	pm-setup [];
	pg-setup []; -- Sets up paging
	svc-setup [];
	kb-setup [];
	asm _ STI ();

	cs-puts [if (ne2k-probe []) then "ne2k detected" else "ne2k not found",];
	cs-nl [];

	ne2k-setup [];

	if (sch-fork []) then (
		cs-puts ["From another thread",];
		cs-nl [];
	) else (
		cs-puts ["From first thread",];
		cs-nl [];
		while 1 do ( -- Halt CPU if none of the process is busy
			asm _ CLI ();
			declare process = head-process;
			declare busy = 0;
			while ((let process = dl-next [process,]) != head-process) do (
				let busy = (busy || `process`/current/busy);
			);
			asm _ STI ();
			(busy ||  asm _ HLT ());
		);
	);

	-- Enters user mode
	declare user-stack-address = pg-allocate [1,];
	user-stack-address + 4096;
	asm _ MOV (EBX, EAX);
	asm _ MOV (EAX, +x23);
	asm _ MOV (DS, AX);
	asm _ MOV (ES, AX);
	asm _ MOV (FS, AX);
	asm _ MOV (GS, AX);
	asm _ PUSH (EAX); -- Would be SS
	asm _ PUSH (EBX); -- Would be ESP
	asm _ PUSHF ();
	asm _ PUSH (+x1B); -- Would be CS
	asm _ D8 (+x68);
	asm _ D32 (.user); -- Would be IP
	asm _ IRET ();

	pg-deallocate [user-stack-address, 1,];
	kb-teardown [];
	sch-teardown [];
)) [];
