	<meta charset='utf-8'>
<html>
	<body>
		<div id='target'></div>
	</body>

	<script src='frp.js'></script>
	<script src='fun.js'></script>

	<script type='text/javascript'>
'use strict';

let c_cud_ = (dom, domc0, insertBefore) => {
	let cud_ = {
		childCud: child_ => c_cud(cud_.childRef, child_),
		childRef: domc0,
		create: c => dom.insertBefore(cud_.childRef = c, insertBefore),
		delete: () => dom.removeChild(cud_.childRef),
		update: c => { let c0 = cud_.childRef; dom.replaceChild(cud_.childRef = c, c0); },
	};
	return cud_;
};

let c_cud = (dom, domc0) => c_cud_(dom, domc0, null);
let c_insertHead = dom => c_cud_(dom, null, dom.firstChild);
let c_insertTail = dom => c_cud_(dom, null, null);

/*
	a typical renderer has 4 parameters:
	vm0 - old view model, null to append DOM elements
	vm1 - new view model, null to remove DOM elements
	cud - DOM manipulator (create, update, delete)
	The renderer should detect the differences and apply changes using cud.
*/

let rd_cd = (cf, df) => (vm0, vm1, cudf) => {
	if (vm0 == vm1)
		;
	else {
		vm0 != null && df(vm0, cudf);
		vm1 != null && cf(vm1, cudf);
	}
};

let rd_element = elementf => rd_cd(
	(vm, cudf) => cudf.create(elementf(vm)),
	(vm, cudf) => cudf.delete()
);

let rd_elementDecors = (elementf, decorfs) => (vm0, vm1, cudf) => {
	if (vm0 == null)
		cudf.create(elementf());
	if (vm0 == vm1)
		;
	else
		for (let decorf of decorfs)
			decorf(vm0, vm1, cudf);
	if (vm1 == null)
		cudf.delete();
};

let rd_for = (keyf, rd_item) => (vm0, vm1, cudf) => {
	let domc0 = cudf.childRef;
	let children0 = domc0 != null ? Array.from(domc0.childNodes) : null;

	if (vm0 == vm1)
		;
	else if (vm0 == null)
		for (let i1 = 0; i1 < vm1.length; i1++)
			rd_item(null, vm1[i1], cudf.childCud(null));
	else if (vm1 == null)
		for (let i0 = 0; i0 < vm0.length; i0++)
			rd_item(vm0[i0], null, cudf.childCud(children0[i0]));
	else {
		let map0 = new Map();
		let map1 = new Map();

		for (let i0 = 0; i0 < vm0.length; i0++)
			map0.set(keyf(vm0[i0]), i0);
		for (let i1 = 0; i1 < vm1.length; i1++)
			map1.set(keyf(vm1[i1]), i1);

		let isSameOrder = vm0.length == vm1.length;

		for (let i1 = 0; i1 < vm1.length; i1++) {
			let i0 = map0.get(keyf(vm1[i1]));
			isSameOrder &= i0 == i1;
		}

		if (isSameOrder)
			for (let i = 0; i < vm1.length; i++)
				rd_item(vm0[i], vm1[i], cudf.childCud(children0[i]));
		else {
			let domc1 = domc0.cloneNode(false);
			cudf.update(domc1);

			for (let i1 = 0; i1 < vm1.length; i1++) {
				let i0 = map0.get(keyf(vm1[i1]));
				if (i0 != null) {
					let child0 = children0[i0];
					domc1.appendChild(child0);
					rd_item(vm0[i0], vm1[i1], cudf.childCud(child0));
				} else
					rd_item(null, vm1[i1], cudf.childCud(null));
			}

			for (let i0 = 0; i0 < vm0.length; i0++)
				if (!map1.has(keyf(vm0[i0])))
					rd_item(vm0[i0], null, c_cud(domc0, children0[i0]));
		}
	}
};

let rd_forRange = (vmsf, rangef, rd_item) => (vm0, vm1, cudf) => {
	let domc0 = cudf.childRef;
	let children0 = domc0 != null ? Array.from(domc0.childNodes) : null;

	if (vm0 == vm1)
		;
	else if (vm0 == null) {
		let [s, e] = rangef(vm1), vms1 = vmsf(vm1);
		for (let i1 = s; i1 < e; i1++)
			rd_item(null, vms1[i1], cudf.childCud(null));
	} else if (vm1 == null) {
		let [s, e] = rangef(vm0), vms0 = vmsf(vm0);
		for (let i0 = s; i0 < e; i0++)
			rd_item(vms0[i0], null, cudf.childCud(children0[i0]));
	} else {
		let [si, ei] = rangef(vm0), vms0 = vmsf(vm0);
		let [sx, ex] = rangef(vm1), vms1 = vmsf(vm1);
		let s_ = si;
		let e_ = ei;

		while (s_ < e_ && s_ < sx)
			rd_item(vms0[s_++], null, cudf.childCud(domc0.firstChild));

		while (s_ < e_ && ex < e_)
			rd_item(vms0[--e_], null, cudf.childCud(domc0.lastChild));

		if (s_ == e_)
			s_ = e_ = sx;

		while (sx < s_)
			rd_item(null, vms1[--s_], c_insertHead(domc0));

		while (e_ < ex)
			rd_item(null, vms1[e_++], c_insertTail(domc0));

		for (let i = Math.max(si, sx); i < Math.min(ei, ex); i++)
			rd_item(vms0[i], vms1[i], cudf.childCud(domc0.childNodes[i - s_]));
	}
};

let rd_ifElse = (iff, thenf, elsef) => (vm0, vm1, cudf) => {
	if (vm0 == vm1)
		;
	else {
		let f0 = vm0 != null && (iff(vm0) ? thenf : elsef);
		let f1 = vm1 != null && (iff(vm1) ? thenf : elsef);

		if (f0 == f1)
			f0(vm0, vm1, cudf);
		else {
			f0 != null && f0(vm0, null, cudf);
			f1 != null && f1(null, vm1, cudf);
		}
	}
};

let rd_tagAttrs = attrs => (vm0, vm1, cudf) => {
	if (vm0 == null)
		for (let [key, value] of Object.entries(attrs))
			cudf.childRef.setAttribute(key, value);
	if (vm1 == null)
		for (let [key, value] of Object.entries(attrs))
			cudf.childRef.removeAttribute(key);
};

let rd_tagAttrsf = attrsf => (vm0, vm1, cudf) => {
	if (vm0 == vm1)
		;
	else if (vm1 != null)
		for (let [key, value] of Object.entries(attrsf(vm1)))
			cudf.childRef.setAttribute(key, value);
	else
		for (let [key, value] of Object.entries(attrsf(vm0)))
			cudf.childRef.removeAttribute(key);
};

let rd_tagChildren = childrenfs => (vm0, vm1, cudf) => {
	let domc0 = cudf.childRef;
	let children0 = domc0 != null ? Array.from(domc0.childNodes) : null;

	if (vm0 == vm1)
		;
	else
		for (let i = 0; i < childrenfs.length; i++)
			childrenfs[i](vm0, vm1, cudf.childCud(domc0 != null ? children0[i] : null));
};

let rd_tagEventListener = (event, cb) => rd_cd(
	(vm, cudf) => cudf.childRef.addEventListener(event, cb),
	(vm, cudf) => cudf.childRef.removeEventListener(event, cb)
);

let rd_tagStyle = style => (vm0, vm1, cudf) => {
	if (vm0 == null)
		for (let [key, value] of Object.entries(style))
			cudf.childRef.style[key] = value;
	if (vm1 == null)
		for (let [key, value] of Object.entries(style))
			cudf.childRef.style[key] = null;
};

let rd_tagStylef = stylef => (vm0, vm1, cudf) => {
	if (vm0 == vm1)
		;
	else if (vm1 != null)
		for (let [key, value] of Object.entries(stylef(vm1)))
			cudf.childRef.style[key] = value;
	else
		for (let [key, value] of Object.entries(stylef(vm0)))
			cudf.childRef.style[key] = null;
};

let rd_tag = (elementf, decorfs) => {
	let decor = decorf => rd_tag(elementf, [...decorfs, decorf,]);
	let attrs = attrs => decor(rd_tagAttrs(attrs));
	let children = childrenfs => decor(rd_tagChildren(childrenfs));
	let child = childf => children([childf]);

	return {
		attr: (key, value) => attrs({ [key]: value, }),
		attrs,
		attrsf: attrsf => decor(rd_tagAttrsf(attrsf)),
		build: () => rd_elementDecors(elementf, decorfs),
		child,
		children: (...childrenfs) => children(childrenfs),
		decor,
		for_: (keyf, rd_item) => decor(rd_for(keyf, rd_item)),
		listen: (event, cb) => decor(rd_tagEventListener(event, cb)),
		style: style => decor(rd_tagStyle(style)),
		stylef: stylef => decor(rd_tagStylef(stylef)),
		text: () => child(rd_element(vm => document.createTextNode(vm))).build(),
	};
};

let rd_vscrollf = (height, rowHeight, rd_item, cbScroll) => {
	let nItemsShown = Math.floor(height / rowHeight) + 1;

	return rd
		.tag('div')
		.style({ height: height + 'px', overflow: 'auto', position: 'absolute', })
		.listen('scroll', d => cbScroll(Math.floor(d.target.scrollTop / rowHeight)))
		.child(rd
			.tag('div')
			.stylef(vm => ({
				height: (vm.vms.length - vm.start) * rowHeight + 'px', position: 'relative', top: vm.start * rowHeight + 'px',
			}))
			.decor((vm0, vm1, cudf) => rd_forRange(
				vm => vm.vms,
				vm => [vm.start, vm.start + nItemsShown],
				rd_tag(() => document.createElement('div'), []).style({ height: rowHeight + 'px', }).child(rd_item).build())
				(vm0, vm1, cudf))
			.build()
		);
};

let rd = {
	element: rd_element,
	if_: (iff, thenf) => rd_ifElse(iff, thenf, rd_element(() => document.createComment('else'))),
	ifElse: rd_ifElse,
	scope: (key, rdf) => (vm0, vm1, cudf) => rdf(
		vm0 != null ? vm0[key] : null,
		vm1 != null ? vm1[key] : null,
		cudf
	),
	tag: tag => rd_tag(() => document.createElement(tag), []),
	vscrollf: rd_vscrollf,
};

let pvm = null;

let renderAgain = (renderer, f) => {
	let target = document.getElementById('target');
	let ppvm = pvm;
	renderer(ppvm, pvm = f(pvm), c_cud(target, target.firstChild));
};

let rd_vm = rd
	.tag('span')
	.style({ 'font-family': 'sans-serif', })
	.children(
		rd.scope('message',
			rd.tag('p').style({ 'font-weight': 'bold', }).text()
		),
		rd.scope('t',
			rd.tag('p').text()
		),
		rd.scope('fruits',
			rd.tag('ul').for_(vm => vm, rd.tag('li').text()).build()
		),
		rd.scope('vscroll', rd
			.vscrollf(200, 32,
				rd.element(vm => document.createTextNode('scrolling ' + vm)),
				start => renderAgain(rd_vm, vm => ({ ...vm, vscroll: { ...vm.vscroll, start, }, })),
			)
			.style({ width: '400px', })
			.build()
		),
	)
	.build();

let t = 0;
let vscroll = { start: 0, vms: read().range(0, 256).list(), };

setInterval(() => renderAgain(rd_vm, vm => ({ ...vm, t: vm.t + 1, })), 1000);

renderAgain(rd_vm, vm => ({ t, vscroll, message: 'hello world0', fruits: ['banana',], }));
renderAgain(rd_vm, vm => ({ t, vscroll, message: 'hello world1', fruits: ['apple', 'banana',], }));
renderAgain(rd_vm, vm => ({ t, vscroll, message: 'hello world2', fruits: ['apple', 'orange', 'orange', 'banana',], }));
renderAgain(rd_vm, vm => ({ t, vscroll, message: 'hello world~', fruits: ['banana', 'orange',], }));
	</script>

</html>
