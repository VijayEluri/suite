-------------------------------------------------------------------------------
-- deterministic analysis

group-predicates (.head :- .tail # .remains) (IN = .head, .tail; .groupedRemains)
	:- group-predicates .remains .groupedRemains
#
group-predicates () fail #

replace-cut-points .predicates0 (DEFINE-CUT .cutPoint .predicates1)
       :- replace .predicates0 .predicates1 ! .cutPoint
#

is-determ (!, _) #
is-determ (.a, .b) :- is-determ .a, is-determ .b #
is-determ (fail; .c) :- is-determ .c #
is-determ (.c; fail) :- is-determ .c #
is-determ (.ifThen; .else)
	:- split-cut .ifThen .then
	, is-determ .then
	, is-determ .else
#
is-determ (.a = .b) #
is-determ yes #
is-determ fail #

split-cut ! () #
split-cut (!, .c) .c #
split-cut (_, .c0) .c1 :- split-cut .c0 .c1 #

-------------------------------------------------------------------------------
-- format check

define-signature .sign :- signature-prototype .sign .sign #

check-module-types (.rule # .remains) :- check-clause-types .rule, check-module-types .remains #
check-module-types () #

check-clause-types (.head :- .clause) :- check-rule-types .head .clause #
check-clause-types .head :- not (head = ()), check-rule-types .head () #
check-clause-types () #

check-clause-types (.c1, .c2) :- check-clause-types .c1, check-clause-types .c2 #
check-clause-types (.c1; .c2) :- check-clause-types .c1, check-clause-types .c2 #
check-clause-types (.c1 = .c2) :- is-type .type .c1, is-type .type .c2 #

check-rule-types .head .clause
	:- prototype .head .proto
	, retrieve-signature .head .types
	, is-type .types .head
	, check-clause-types .clause
#

is-type %any _ #
is-type %integer .i :- is.int .i #
is-type %string .s :- is.string .s #
is-type (.type | _) .e :- is-type .type .e #
is-type (_ | .remains) .e :- is-type .remains .e #
is-type (%list .type) (.head, .remains)
	:- is-type .type .head
	, is-type (%list .type) .remains
#
is-type .alias .e :- map.retrieve (TYPE-ALIAS .alias, .value), bound .value, is-type .value .e #
is-type .treeType .tree
	:- tree .tree .left .operator .right
	, tree .treeType .leftType .operator .rightType
	, is-type .leftType .left, is-type .rightType .right
#
is-type .a .a :- is.atom .a, not (starts.with .a '%') #

signature-prototype .sign .proto :- prototype .sign .proto, map.retrieve (SIGNATURE .sign, .proto) #

prototype (.head .remains0) (.head .remains1) :- params-prototype .remains0 .remains1, ! #

params-prototype (_, .remains0) ((), .remains1) :- params-prototype .remains0 .remains1, ! #
params-prototype () () #

-------------------------------------------------------------------------------
-- functional programming

gen-func-code .predicate .c0/.r :- gen-func-code 0 .predicate .c0/()/.r #

gen-func-code .frame %REG/.reg/.frame .c/.c/.reg :- ! #
gen-func-code .frame1 %REG/.reg/.frame .c0/.cx/.reg1
	:- !, let .frameDifference (.frame - .frame1)
	, .c0 = (ASSIGN-FRAME-REG .reg1 .frameDifference .reg, .cx)
#
gen-func-code .frame .i .c0/.cx/.reg :- is.int .i, .c0 = (ASSIGN-INT .reg .i, .cx) #
gen-func-code .frame .s .c0/.cx/.reg :- is.string .s, .c0 = (ASSIGN-STR .reg .s, .cx) #
gen-func-code .frame .b .c0/.cx/.reg :- is.boolean .b, !, .c0 = (ASSIGN-BOOL .reg .b, .cx) #
gen-func-code .frame .f .c0/.cx/.reg :- is.atom .f, .c0 = (ASSIGN-FUNC .reg .f, .cx) #
gen-func-code .frame (.variable = .value >> .do) .c0/.cx/.reg
	:- !
	, gen-func-code .frame .value .c0/.c1/.r1
	, replace .do .do1 .variable %REG/.r1/.frame
	, gen-func-code .frame .do1 .c1/.cx/.reg
#
gen-func-code .frame (.variable => .do) .c0/.cx/.reg
	:- !
	, let .frame1 (.frame + 1)
	, .c0 = (JUMP .skipLabel, LABEL .funcLabel, POP .variableRegister, .c1)
	, replace .do .do1 .variable %REG/.variableRegister/.frame1
	, (
		.do1 = (case | .matches)
		, !, match-code .variableRegister .frame1 .matches .c1/.c2/.rr
	;
		gen-func-code .frame1 .do1 .c1/.c2/.rr
	)
	, .c2 = (RETURN .rr, LABEL .skipLabel, ASSIGN-LABEL .reg .funcLabel, .cx)
#
gen-func-code .frame (.caller {.parameter}) .c0/.cx/.reg
	:- !
	, gen-func-code .frame .caller .c0/.c1/.r1
	, gen-func-code .frame .parameter .c1/.c2/.r2
	, .c2 = (PUSH .r2, CALL .reg .r1, .cx)
#
gen-func-code .frame (.if ? .then | .else) .c0/.cx/.reg
	:- !
	, gen-func-code .frame .if .c0/.c1/.cr
	, .c1 = (IF-FALSE .cr .label1, .c2)
	, gen-func-code .frame .then .c2/.c3/.reg
	, .c3 = (JUMP .label2, LABEL .label1, .c4)
	, gen-func-code .frame .else .c4/.c5/.reg
	, .c5 = (LABEL .label2, .cx)
#
gen-func-code .frame .tree .c0/.cx/.reg
	:- tree .tree .left .oper .right
	, gen-func-code .frame .left .c0/.c1/.r1
	, gen-func-code .frame .right .c1/.c2/.r2
	, .c2 = (EVALUATE .reg .r1 .oper .r2, .cx)
#

match-code .vr .frame (.value >> .then | .else) .c0/.cx/.reg
	:- !, gen-func-code .frame .value .c0/.c1)/.cr
	, .c1 = (IF-NE .vr .cr .label1, .c2)
	, gen-func-code .frame .then .c2/.c3/.reg
	, .c3 = (JUMP .label2, LABEL .label1, .c4)
	, match-code .vr .frame .else .c4/.c5/.reg
	, .c5 = (LABEL .label2, .cx)
#
match-code _ .frame .otherwise .snippet :- gen-func-code .frame .otherwise .snippet #

is.boolean true #
is.boolean false #

-------------------------------------------------------------------------------
-- logical programming

compile () () (.c .c) #
compile () .more (.c0 .cx) :- compile .more () (.c0 .cx) #
compile () (JMP .label) (.c0 .cx) :- .c0 = (JMP .label, .cx) #
compile (.a, .b) .more (.c0 .cx) :- compile .a (.b, .more) (.c0 .cx) #
compile (.a; .b) .more (.c0 .cx)
	:- .c0 = (PUSH-BACKTRACK-POINT, .c1)
	, compile .a (JMP .label) .c1 .c2
	, .c2 = (LABEL .label, .c3)
	, compile .a () .c3 .cx
#
compile (.a = .b) .more (.c0 .cx)
	:- create-node .a .reg0 (.c0 .c1)
	, create-node .a .reg1 (.c1 .c2)
	, .c2 = (JUMP-FAIL .reg0 .reg1, .cx)
#

create-node .a .reg (.c0 .cx) :- is.atom .a, .c0 = (ASSIGN-ATOM .reg .a, .cx) #
create-node .i .reg (.c0 .cx) :- is.int .i, .c0 = (ASSIGN-INT .reg .i, .cx) #
create-node .s .reg (.c0 .cx) :- is.string .s, .c0 = (ASSIGN-STR .reg .s, .cx) #
create-node .tree .reg (.c0 .cx)
	:- tree .tree .left .operator .right
	, create-node .left .regl (.c0 .c1)
	, create-node .right .regr (.c1 .c2)
	, .c2 = (FORM-TREE .operator .regl .regr, .cx)
#

is-user-predicate .call :- was-success (is-user-predicate0 .call) #

is-user-predicate0 .call :- rules .rules, has-rules .rules (.call :- _) #

has-rules (.rule # _) .rule #
has-rules (_ # .remains) .rule :- has-rules .remains .rule #

-------------------------------------------------------------------------------
-- pattern recog

-------------------------------------------------------------------------------
-- lexer

-------------------------------------------------------------------------------
-- longest common subsequence

lcs () _ () :- ! #
lcs _ () () :- ! #
lcs (.common, .remains1) (.common, .remains2) (.common, .lcs)
	:- lcs-once .remains1 .remains2 .lcs, !
#
lcs (.head1, .remains1) (.head2, .remains2) .lcs
	:- lcs-once (.head1, .remains1) .remains2 .lcs1
	, lcs-once .remains1 (.head2, .remains2) .lcs2
	, longest .lcs1 .lcs2 .lcs
#

-- Note memory leak
lcs-once .a .b .lcs :- map.retrieve (LCS .a .b) .lcs, (bound .lcs, !; lcs .a .b .lcs) #

longest .l .r .result
	:- longest0 .l .r L, !, .result = .l; .result = .r
#

longest0 .l () L #
longest0 () .l R #
longest0 (_, .l1) (_, .l2) .which :- longest0 .l1 .l2 .which #
