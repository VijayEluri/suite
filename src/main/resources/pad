-- 2-3 tree indexer

-- typing

-- compiler

compile () () (.c .c) #
compile () .more (.c0 .cx)
	:- compile .more () (.c0 .cx) #
compile () (JMP .label) (.c0 .cx)
	:- (JMP .label, .c0) = .cx #
compile (.a, .b) .more (.c0 .cx)
	:- compile .a (.b, .more) (.c0 .cx) #
compile (.a; .b) .more (.c0 .cx)
	:- (.c0, PUSH-BACKTRACK-POINT) = .c1
	, compile .a (JMP .label) .c1 .c2
	, (LABEL .label, .c2) = .c3
	, compile .a () .c3 .cx #
compile (.a = .b) .more (.c0 .cx)
	:- createNode .a .reg0 (.c0 .c1)
	, createNode .a .reg1 (.c1 .c2)
	, (FAIL-IF-DIFF .reg0 .reg1, .c2) = .cx #

createNode .atom .reg (.c0 .cx)
	:- is.atom .atom
	, (ASSIGN-ATOM .reg .atom, .c0) = .cx #
createNode .i .reg (.c0 .cx)
	:- is.int .i
	, (ASSIGN-INT .reg .i, .c0) = .cx #
createNode .str .reg (.c0 .cx)
	:- is.string .str
	, (ASSIGN-STRING .reg .str, .c0) = .cx #
createNode .tree .reg (.c0 .cx)
	:- tree .tree .left .operator .right
	, createNode .left .regl (.c0 .c1)
	, createNode .right .regr (.c1 .c2)
	, (FORM-TREE .operator .regl .regr, .c2) = .cx #
	