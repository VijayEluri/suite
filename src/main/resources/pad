-------------------------------------------------------------------------------
-- deterministic analysis

group-predicates (.head :- .tail # .remains) (IN = .head, .tail; .groupedRemains)
	:- group-predicates .remains .groupedRemains
#
group-predicates () fail #

replace-cut-points .predicates0 (DEFINE-CUT .cutPoint .predicates1)
       :- replace .predicates0 .predicates1 ! .cutPoint
#

is-determ (!, _) #
is-determ (.a, .b) :- is-determ .a, is-determ .b #
is-determ (fail; .c) :- is-determ .c #
is-determ (.c; fail) :- is-determ .c #
is-determ (.ifThen; .else)
	:- split-cut .ifThen .then
	, is-determ .then
	, is-determ .else
#
is-determ (.a = .b) #
is-determ yes #
is-determ fail #

split-cut ! () #
split-cut (!, .c) .c #
split-cut (_, .c0) .c1 :- split-cut .c0 .c1 #

-------------------------------------------------------------------------------
-- format check

define-signature .sign :- signature-prototype .sign .sign #

check-module-types (.rule # .remains) :- check-clause-types .rule, check-module-types .remains #
check-module-types () #

check-clause-types (.head :- .clause) :- check-rule-types .head .clause #
check-clause-types .head :- not (head = ()), check-rule-types .head () #
check-clause-types () #

check-clause-types (.c1, .c2) :- check-clause-types .c1, check-clause-types .c2 #
check-clause-types (.c1; .c2) :- check-clause-types .c1, check-clause-types .c2 #
check-clause-types (.c1 = .c2) :- is-type .type .c1, is-type .type .c2 #

check-rule-types .head .clause
	:- prototype .head .proto
	, retrieve-signature .head .types
	, is-type .types .head
	, check-clause-types .clause
#

is-type %any _ #
is-type %integer .i :- is.int .i #
is-type %string .s :- is.string .s #
is-type (.type | _) .e :- is-type .type .e #
is-type (_ | .remains) .e :- is-type .remains .e #
is-type (%list .type) (.head, .remains)
	:- is-type .type .head
	, is-type (%list .type) .remains
#
is-type .alias .e :- map.retrieve (TYPE-ALIAS .alias, .value), bound .value, is-type .value .e #
is-type .treeType .tree
	:- tree .tree .left .operator .right
	, tree .treeType .leftType .operator .rightType
	, is-type .leftType .left, is-type .rightType .right
#
is-type .a .a :- is.atom .a, not (starts.with .a '%') #

signature-prototype .sign .proto :- prototype .sign .proto, map.retrieve (SIGNATURE .sign, .proto) #

prototype (.head .remains0) (.head .remains1) :- params-prototype .remains0 .remains1, ! #

params-prototype (_, .remains0) ((), .remains1) :- params-prototype .remains0 .remains1, ! #
params-prototype () () #

-------------------------------------------------------------------------------
-- functional programming

load-func .f (.c0 .cx) .reg :- is.atom .f, .c0 = (ASSIGN-FUNC .reg .f, .cx) #
load-func .p (.c0 .cx) .reg
	:- .c0 = (JUMP .skipLabel, LABEL .funcLabel, .c1)
	, gen-func-code .p (.c1 .c2) .reg
	, .c2 = (LABEL .skipLabel, ASSIGN-FUNC .reg .funcLabel, .cx)
#

gen-func-code (%REG .r) (.c0 .cx) .r :- ! #
gen-func-code .i (.c0 .cx) .reg :- is.int .i, .c0 = (ASSIGN-INT .reg .i, .cx) #
gen-func-code .s (.c0 .cx) .reg :- is.string .s, .c0 = (ASSIGN-STR .reg .s, .cx) #
gen-func-code .b (.c0 .cx) .reg :- is.boolean .b, .c0 = (ASSIGN-BOOL .reg .b, .cx) #
gen-func-code (.if ? .then | .else) (.c0 .cx) .reg
	:- gen-func-code .if (.c0 .c1) .cr
	, .c1 = (IF-FALSE .cr .label1, .c2)
	, gen-func-code .then (.c2 .c3) .reg
	, .c3 = (JUMP .label2, LABEL .label1, .c4)
	, gen-func-code .then (.c4 .c5) .reg
	, .c5 = (LABEL .label2, .cx)
#
gen-func-code (case | .matches) (.c0 .cx) .reg
	:- .c0 = (POP .vr, .c1)
	, match-code .vr .matches (.c1 .cx) .reg
#
gen-func-code (.var => .do) (.c0 .cx) .reg
	:- .c0 = (POP .vr, .c1)
	, replace .d0 .do1 .var (%REG .vr)
	, gen-func-code .do (.c1 .cx) .reg
#
gen-func-code (.var = .value >> .do) (.c0 .cx) .reg
	:- gen-func-code .value (.c0 .c1) .r1
	, replace .do .do1 .var (%REG .r1)
	, gen-func-code .do1 .c1 .c2 .reg
#
gen-func-code (.caller {.p}) (.c0 .cx) .reg
	:- !
	, load-func-code .caller (.c0 .c1) .r1
	, gen-func-code .p (.c1 .c2) .r2
	, .c2 = (PUSH .r2, CALL .r1, .cx)
#
gen-func-code .t (.c0 .cx) .reg
	:- tree .t .left .oper .right
	, gen-func-code .left (.c0 .c1) .r1
	, gen-func-code .right (.c1 .c2) .r2
	, .c2 = (EVALUATE .cx .left .oper .right, .cx)
#

match-code .vr (.value >> .then | .else) (.c0 .cx) .reg
	:- !, gen-func-code .value (.c0 .c1) .cr
	, .c1 = (IF-NE .vr .cr .label1, .c2)
	, gen-func-code .then (.c2 .c3) .reg
	, .c3 = (JUMP .label2, LABEL .label1, .c4)
	, match-code .vr .else (.c4 .c5) .reg
	, .c5 = (LABEL .label2, .cx)
#
match-code _ .otherwise (.c0 .cx) .reg :- gen-func-code .otherwise (.c0 .cx) .reg #

is.boolean true #
is.boolean false #

-------------------------------------------------------------------------------
-- logical programming

compile () () (.c .c) #
compile () .more (.c0 .cx)
	:- compile .more () (.c0 .cx)
#
compile () (JMP .label) (.c0 .cx)
	:- .c0 = (JMP .label, .cx)
#
compile (.a, .b) .more (.c0 .cx)
	:- compile .a (.b, .more) (.c0 .cx)
#
compile (.a; .b) .more (.c0 .cx)
	:- .c0 = (PUSH-BACKTRACK-POINT, .c1)
	, compile .a (JMP .label) .c1 .c2
	, .c2 = (LABEL .label, .c3)
	, compile .a () .c3 .cx
#
compile (.a = .b) .more (.c0 .cx)
	:- create-node .a .reg0 (.c0 .c1)
	, create-node .a .reg1 (.c1 .c2)
	, .c2 = (JUMP-FAIL .reg0 .reg1, .cx)
#

create-node .a .reg (.c0 .cx) :- is.atom .a, .c0 = (ASSIGN-ATOM .reg .a, .cx) #
create-node .i .reg (.c0 .cx) :- is.int .i, .c0 = (ASSIGN-INT .reg .i, .cx) #
create-node .s .reg (.c0 .cx) :- is.string .s, .c0 = (ASSIGN-STR .reg .s, .cx) #
create-node .tree .reg (.c0 .cx)
	:- tree .tree .left .operator .right
	, create-node .left .regl (.c0 .c1)
	, create-node .right .regr (.c1 .c2)
	, .c2 = (FORM-TREE .operator .regl .regr, .cx)
#

is-user-predicate .call :- was-success (is-user-predicate0 .call) #

is-user-predicate0 .call :- rules .rules, has-rules .rules (.call :- _) #

has-rules (.rule # _) .rule #
has-rules (_ # .remains) .rule :- has-rules .remains .rule #

-------------------------------------------------------------------------------
-- pattern recog

-------------------------------------------------------------------------------
-- lexer

-------------------------------------------------------------------------------
-- longest common subsequence

lcs () _ () :- ! #
lcs _ () () :- ! #
lcs (.common, .remains1) (.common, .remains2) (.common, .lcs)
	:- lcs-once .remains1 .remains2 .lcs, !
#
lcs (.head1, .remains1) (.head2, .remains2) .lcs
	:- lcs-once (.head1, .remains1) .remains2 .lcs1
	, lcs-once .remains1 (.head2, .remains2) .lcs2
	, longest .lcs1 .lcs2 .lcs
#

-- Note memory leak
lcs-once .a .b .lcs :- map.retrieve (LCS .a .b) .lcs, (bound .lcs, !; lcs .a .b .lcs) #

longest .l .r .result
	:- longest0 .l .r L, !, .result = .l; .result = .r
#

longest0 .l () L #
longest0 () .l R #
longest0 (_, .l1) (_, .l2) .which :- longest0 .l1 .l2 .which #
