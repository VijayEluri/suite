	<meta charset='utf-8'>
<html>
	<body>
		<div id='target'></div>
	</body>

	<script src='frp.js'></script>
	<script src='fun.js'></script>

	<script type='text/javascript'>
'use strict';

/*
	a typical renderer has 4 parameters:
	vm0 - old view model, null to append DOM elements
	vm1 - new view model, null to remove DOM elements
	dom - current DOM parent node
	domc - current DOM node
	The renderer should detect the differences and apply changes under dom, or directly update domc.
*/

let rd_cd = (cf, df) => (vm0, vm1, dom, domc) => {
	if (vm0 == vm1)
		;
	else {
		vm0 != null && df(vm0, dom, domc);
		vm1 != null && cf(vm1, dom, domc);
	}
};

let rd_child = elementf => rd_cd(
	(vm, dom, domc) => dom.appendChild(domc = elementf(vm)),
	(vm, dom, domc) => dom.removeChild(domc)
);

let rd_element = (elementf, decorfs) => (vm0, vm1, dom, domc) => {
	if (vm0 == null)
		dom.appendChild(domc = elementf());
	if (vm0 != vm1)
		for (let decorf of decorfs)
			decorf(vm0, vm1, dom, domc);
	if (vm1 == null)
		dom.removeChild(domc);
};

let rd_ifElse = (iff, thenf, elsef) => (vm0, vm1, dom, domc) => {
	if (vm0 == vm1)
		;
	else {
		let f0 = vm0 != null && (iff(vm0) ? thenf : elsef);
		let f1 = vm1 != null && (iff(vm1) ? thenf : elsef);

		if (f0 == f1)
			f0(vm0, vm1, dom, domc);
		else {
			f0 != null && f0(vm0, null, dom, domc);
			f1 != null && f1(null, vm1, dom, domc);
		}
	}
};

let rd_tagAttrsf = attrsf => (vm0, vm1, dom, domc) => {
	if (vm0 == vm1)
		;
	else if (vm1 != null)
		for (let [key, value] of Object.entries(attrsf(vm1)))
			domc.setAttribute(key, value);
	else
		for (let [key, value] of Object.entries(attrsf(vm0)))
			domc.removeAttribute(key);
};

let rd_tagAttrs = attrs => rd_cd(
	(vm, dom, domc) => {
		for (let [key, value] of Object.entries(attrs))
			domc.setAttribute(key, value);
	}, 
	(vm, dom, domc) => {
		for (let [key, value] of Object.entries(attrs))
			domc.removeAttribute(key);
	},
);

let rd_tagChildren = childrenfs => (vm0, vm1, dom, domc) => {
	if (vm0 == vm1)
		;
	else if (vm0 == null)
		for (let i = 0; i < childrenfs.length; i++)
			childrenfs[i](vm0, vm1, domc, null);
	else if (vm1 == null) {
		let children = Array.from(domc.childNodes);
		for (let i = 0; i < childrenfs.length; i++)
			childrenfs[i](vm0, vm1, domc, children[i]);
	} else
		for (let i = 0; i < childrenfs.length; i++)
			childrenfs[i](vm0, vm1, domc, domc.childNodes[i]);
};

let rd_tagEventListener = (event, cb) => rd_cd(
	(vm, dom, domc) => domc.addEventListener(event, cb),
	(vm, dom, domc) => domc.removeEventListener(event, cb)
);

let rd_tagFor = (keyf, rdf) => (vm0, vm1, dom, domc) => {
	if (vm0 == vm1)
		;
	else if (vm0 == null)
		for (let i1 = 0; i1 < vm1.length; i1++)
			rdf(null, vm1[i1], domc, null);
	else if (vm1 == null) {
		let children = Array.from(domc.childNodes);
		for (let i0 = 0; i0 < vm0.length; i0++)
			rdf(vm0[i0], null, domc, children[i0]);
	} else {
		let children = Array.from(domc.childNodes);
		let map0 = new Map();
		let map1 = new Map();

		for (let i0 = 0; i0 < vm0.length; i0++)
			map0.set(keyf(vm0[i0]), i0);
		for (let i1 = 0; i1 < vm1.length; i1++)
			map1.set(keyf(vm1[i1]), i1);

		let isSameOrder = vm0.length == vm1.length;
		let domc0 = domc;

		for (let i1 = 0; i1 < vm1.length; i1++) {
			let i0 = map0.get(keyf(vm1[i1]));
			isSameOrder &= i0 == i1;
		}

		if (isSameOrder)
			for (let i = 0; i < vm1.length; i++)
				rdf(vm0[i], vm1[i], domc, children[i]);
		else {
			let children0 = Array.from(domc0.childNodes);
			dom.replaceChild(domc = domc0.cloneNode(false), domc0);

			for (let i1 = 0; i1 < vm1.length; i1++) {
				let i0 = map0.get(keyf(vm1[i1]));
				if (i0 != null) {
					let child0 = children[i0];
					domc.appendChild(child0);
					rdf(vm0[i0], vm1[i1], domc, child0);
				} else
					rdf(null, vm1[i1], domc, null);
			}

			for (let i0 = 0; i0 < vm0.length; i0++)
				if (!map1.has(keyf(vm0[i0])))
					rdf(vm0[i0], null, domc0, children0[i0]);
		}
	}
};

let rd = {
	child: rd_child,
	if_: (iff, thenf) => rd_ifElse(iff, thenf, rd_child(() => document.createComment('else'))),
	ifElse: rd_ifElse,
	scope: (key, rdf) => (vm0, vm1, dom, domc) => rdf(
		vm0 != null ? vm0[key] : null,
		vm1 != null ? vm1[key] : null,
		dom, domc
	),
	tag: (tag, ...decorfs) => rd_element(() => document.createElement(tag), decorfs),
	tagAttr: (key, value) => rd_tagAttrs({ [key]: value, }),
	tagAttrs: rd_tagAttrs,
	tagAttrsf: rd_tagAttrsf,
	tagChildren: (...childrenfs) => rd_tagChildren(childrenfs),
	tagChildrenList: rd_tagChildren,
	tagFor: rd_tagFor,
	tagListen: rd_tagEventListener,
};

let pvm = null;

let renderAgain = (renderer, f) => {
	let target = document.getElementById('target');
	let ppvm = pvm;
	renderer(ppvm, pvm = f(pvm), target, target.firstChild);
};

let text = rd.child(vm => document.createTextNode(vm));

let rd_vm = rd.tag('span',
	rd.tagAttr('style', 'font-family: Verdana;'),
	rd.tagChildren(
		rd.scope('message',
			rd.tag('p', rd.tagAttr('style', 'font-weight: bold;'), rd.tagChildren(text,))
		),
		rd.scope('fruits',
			rd.tag('ul', rd.tagFor(vm => vm, rd.tag('li', rd.tagChildren(text,))))
		),
		rd.tag('div',
			rd.tagAttr('style', 'height: 200px; overflow: auto; position: absolute;'),
			rd.tagListen('scroll', d => {
				let scrollTop = d.target.scrollTop;
				let start = Math.floor(scrollTop / 32);
				renderAgain(rd_vm, vm => ({ ...vm, start: start, }));
			}),
			rd.tagChildren(rd.tag('div',
				rd.tagAttrsf(vm => ({
					style: 'height: ' + (256 - vm.start) * 32 + 'px; position: relative; top: ' + vm.start * 32 + 'px;',
				})),
				(vm0, vm1, dom, domc) => {
					let list0 = vm => {
						let s = vm.start;
						let e = s + Math.floor(200 / 32) + 1;
						return vm.vms.slice(s, e);
					};

					let list1 = s => s != null ? list0(s) : null;

					rd.tagFor(
						vm => vm,
						rd.tag('div', rd.tagAttr('style', 'height: 32px;'), rd.tagChildren(rd.child(vm => document.createTextNode('scrolling ' + vm)),))
					)(list1(vm0), list1(vm1), dom, domc);
				},
			),),
		),
	)
);

let start = 0;
let vms = [];

for (let i = 0; i < 256; i++)
	vms.push(i);

renderAgain(rd_vm, vm => ({ start, vms, message: 'hello world0', fruits: ['banana',], }));
renderAgain(rd_vm, vm => ({ start, vms, message: 'hello world1', fruits: ['apple', 'banana',], }));
renderAgain(rd_vm, vm => ({ start, vms, message: 'hello world2', fruits: ['apple', 'orange', 'orange', 'banana',], }));
renderAgain(rd_vm, vm => ({ start, vms, message: 'hello world~', fruits: ['banana', 'orange',], }));
	</script>

</html>
